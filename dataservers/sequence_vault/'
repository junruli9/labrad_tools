"""
### BEGIN NODE INFO
[info]
name = SequenceVault
version = 1.0
description = 
instancename SequenceVault

[startup]
cmdline = %PYTHON% %FILE%
timeout = 20

[shutdown]
message = 987654321
timeout = 20
### END NODE INFO
"""

from labrad.server import LabradServer, setting, Signal
from twisted.internet.defer import inlineCallbacks, returnValue

import json
from datetime import date, timedelta
import os

class SequenceVault(LabradServer):
    """
    Data server for compiling experimental sequences and tracking sequence versions
    """
    name = "SequenceVault"

    def __init__(self, config_path='./config.json'):
        self.load_config(config_path)
        self.electrode = {}
        super(SequenceVault, self).__init__()

    def load_config(self, path=None):
        if path is not None:
            self.config_path = path
            with open(path, 'r') as f:
                config = json.load(f)
                for k,v in config.items():
                    setattr(self, k, v)

    @inlineCallbacks
    def initServer(self):
        self.electrode_server = self.client.servers['electrode']
        self.sequencer_server = self.client.servers['sequencer']
        yield self._refresh()

    @inlineCallbacks
    def _refresh(self):
        self.refresh_sequences()
        yield self.refresh_electrode_parameters()

    def refresh_sequences(self):
        self.sequences = {}

        for i in range(365,0,-1):
            d = date.today() - timedelta(i)
            timestr = d.strftime(self.time_format)
            path = self.sequence_path.format(timestr)

            if os.path.isdir(path):
                sequences = os.listdir(path)

                for name in sequences:
                    (fname, version) = self.split_filename(name)
                    if not fname in self.sequences:
                        self.sequences[fname] = {}
                    if not timestr in self.sequences[fname]:
                        self.sequences[fname][timestr] = []
                    self.sequences[name][timestr].append(version)

    @inlineCallbacks
    def refresh_electrode_parameters(self):
        yield self.get_e_presets()
        yield self.get_e_channels()

        print self.electrode['channels']
        
        
    @inlineCallbacks
    def get_e_presets(self):
        self.electrode['presets'] = {}
        presets = yield self.electrode_server.get_presets()
        presets = json.loads(presets)

        for p in presets:
            self.electrode['presets'].update({str(p['id']): p['values']})

    @inlineCallbacks
    def get_e_channels(self):
        self.electrode['channels'] = {}
        e_channels = yield self.electrode_server.get_channels()
        e_channels = json.loads(e_channels)

        all_channels = yield self.sequencer_server.get_channels()
        all_channels = json.loads(all_channels)


        lookup = {}
        for k in all_channels.keys():
            lookup[k.split('@')[-1]] = k

        for k,v in e_channels.items():
            self.electrode['channels'][k] = lookup[v]

    @inlineCallbacks
    @setting(1, "Refresh", returns='i')
    def refresh(self, c):
        try:
            yield self._refresh()
            returnValue(0)
        except Exception as e:
            print "Exception in SequenceVault.refresh: " + e
            returnValue(-1)


    @setting(2, "Get sequences", returns='s')
    def get_sequences(self, c):
        sorted_list = sorted(self.sequences.keys(), key=lambda x: x[0].capitalize())
        return json.dumps(sorted_list)

    @setting(3, "Get dates", sequence_name='s', returns='*s')
    def get_dates(self, c, sequence_name):
        try:
            return sorted(self.sequences[sequence_name].keys())
        except Exception as e:
            print "SequenceVault, exception in Get dates: " + e 
            return []


    @setting(4, "Get versions", sequence_name='s', returns='*s')
    def get_versions(self, c, sequence_name):
        try:
            s = []
            for date in sorted(self.sequences[sequence_name].keys()):
                for x in self.sequences[sequence_name][date]:
                    s.append(date + self.version_suffix + sequence_name + x)
            return s
        except Exception as e:
            print "SequenceVault, exception in Get versions: " + e
            return ['']


    @setting(5, "GetParameterizedSqeuence", sequences='*s', returns='s')
    def get_parameterized_sequence(self, c, sequences):
        joined = self.join_sequence(sequences)
        


        return ''



    def join_sequences(self, sequences):
        seqs = []

        for s in sequences:
            # Get most recent version for now
            date = sorted(self.sequences[s].keys())[-1]
            path = self.sequence_path.format(date) + s
            
            with open(path, 'r') as f:
                seqs.append(json.load(f))

        out = seqs[0]
        for x in seqs[1:]:
            for key in out.keys():
                for k in out[key].keys():
                    out[key][k] += x[key][k]
        return out


    def split_filename(self, filename):
        split = filename.split(self.version_suffix)

        if len(split) == 1:
            return (filename, '')
        else:
            fname = ''.join(split[:-1])
            suffix = split[-1]
            try:
                x = int(suffix[1:])
                return (fname, suffix)
            except:
                return (filename, '')



    def stopServer(self):
        pass

if __name__ == "__main__":
    from labrad import util
    util.runServer(SequenceVault())
