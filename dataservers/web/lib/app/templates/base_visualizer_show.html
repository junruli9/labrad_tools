{% extends "base_visualizer.html" %}

{% block subtitle %}
Plot waveforms
{% endblock %}

{% block subcontent %}

{% if session.0 %}
  <div id="accordion">
    <div class="card">
      <div class="card-header" id="heading-controls">
        <h5 class="mb-0">
          <button class="btn btn-link" data-toggle="collapse" data-target="#collapse-controls" aria-expanded="false" aria-controls="collapse-controls">
            Controls
          </button>
        </h5>
      </div>

      <div id="collapse-controls" class="collapse" aria-labelledby="heading-controls">
        <div class="card-body">
          <div class="row flex-fill">
            <div class="col-sm">
              <div id="accordion-da" class="visualizer-channels" style="overflow-y: scroll;">
                {% for l in digital %}
                  <div class="card">
                    <div class="card-header p-0" id="heading-{{l.device}}">
                      <h5 class="mb-0">
                        <button class="btn btn-link" data-toggle="collapse" data-target="#collapse-{{l.device}}" aria-expanded="false" aria-controls="collapse-{{l.device}}">
                          {{l.device}}
                        </button>
                      </h5>
                    </div>
                
                    <div id="collapse-{{l.device}}" class="collapse" aria-labelledby="heading-{{l.device}}" data-parent="#accordion-da">
                      <div class="card-body">
                        <div class="form-check">
                          <button class="btn btn-primary btn-channel-enable" data-device="{{l.device}}">
                            All on
                          </button>
                          <button class="btn btn-secondary btn-channel-disable" data-device="{{l.device}}">
                            All off
                          </button>
                        </div>
                        {% for loc in l.channels %}
                          <div class="form-check">
                            <input class="form-check-input check-channel check-channel-{{l.device}}" type="checkbox" value={{loc.loc}} id="channel-check-{{loc.loc}}" data-nameloc="{{loc.name}}@{{loc.loc}}" data-type="digital">
                            <label class="form-check-label" for="channel-check-{{loc.loc}}">
                               {{loc.loc}}: {{loc.name}}
                            </label>
                          </div>
                        {% endfor %}
                      </div>
                    </div>
                  </div>
                {% endfor %}

                {% for l in analog %}
                  <div class="card">
                    <div class="card-header p-0" id="heading-{{l.device}}">
                      <h5 class="mb-0">
                        <button class="btn btn-link" data-toggle="collapse" data-target="#collapse-{{l.device}}" aria-expanded="false" aria-controls="collapse-{{l.device}}">
                          {{l.device}}
                        </button>
                      </h5>
                    </div>
                
                    <div id="collapse-{{l.device}}" class="collapse" aria-labelledby="heading-{{l.device}}" data-parent="#accordion-da">
                      <div class="card-body">
                        <div class="form-check">
                          <button class="btn btn-primary btn-channel-enable" data-device="{{l.device}}">
                            All on
                          </button>
                          <button class="btn btn-secondary btn-channel-disable" data-device="{{l.device}}">
                            All off
                          </button>
                        </div>
                        {% for loc in l.channels %}
                          <div class="form-check">
                            <input class="form-check-input check-channel check-channel-{{l.device}}" type="checkbox" value={{loc.loc}} id="channel-check-{{loc.loc}}" data-nameloc="{{loc.name}}@{{loc.loc}}" data-type="analog">
                            <label class="form-check-label" for="channel-check-{{loc.loc}}">
                              {{loc.name}}
                            </label>
                          </div>
                        {% endfor %}
                      </div>
                    </div>
                  </div>
                {% endfor %}
              </div>
            </div>
            <div class="col-sm">
              <div class="row flex-fill">
                <button class="btn btn-primary btn-channel-all-on">
                  All channels on
                </button>
                <button class="btn btn-secondary btn-channel-all-off">
                  All channels off
                </button>
              </div>

              <div class="row flex-fill">
                <div class="form-row">
                  <div class="form-group">
                    <label for="select-jump">
                      Jump to sequence:
                    </label>
                    <select class="form-control" id="select-jump">
                    </select>
                  </div>
                </div>
                <div class="form-row">
                  <div class="col">
                    <label for="input-time-start">
                      Start (ms)
                    </label>
                    <input class="form-control input-time" type="text" id="input-time-start">
                  </div>
                  <div class="col">
                    <label for="input-time-stop">
                      Stop (ms)
                    </label>
                    <input class="form-control input-time" type="text" id="input-time-stop">
                  </div>
                </div>
                <div class="form-row">
                  <div class="form-check">
                    <input class="form-check-input check-scale" type="checkbox" id="check-scale" value="" checked>
                    <label class="form-check-label" for="check-scale">
                      Scale values over view?
                    </label>
                  </div>
                </div>
              </div>

            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="card-header" id="heading-plots">
        <h5 class="mb-0">
          <button class="btn btn-link" data-toggle="collapse" data-target="#collapse-plots" aria-expanded="false" aria-controls="collapse-plots">
            Plots
          </button>
        </h5>
      </div>

      <div id="collapse-plots" class="collapse" aria-labelledby="heading-plots">
        <div class="card-body">
          <div class="row flex-fill">
            <div class="btn-group btn-group-toggle" data-toggle="buttons">
              <label class="btn btn-primary">
                <input type="radio" name="plot-options" id="option1" autocomplete="off">Ridgeline
              </label>
              <label class="btn btn-primary">
                <input type="radio" name="plot-options" id="option2" autocomplete="off">Digital + Analog
              </label>
              <label class="btn btn-primary">
                <input type="radio" name="plot-options" id="option3" autocomplete="off">One axes
              </label>
            </div>
          </div>
          <div class="row flex-fill">
            <div class="visualizer-canvas flex-fill" style="overflow-y: scroll; overflow-x: scroll;"> 
              <svg></svg>
            </div>
          </div>
        </div>
      </div>
    </div>

  </div>

  <script>
    var checkState = {
      last: -1,
      shiftPressed: false,
      lookupList: []
    };
    var typeLookup = [];
    var sequence; var meta;
    var sequence_array = [];
    var svg = d3.select("svg");
    var line, x, y, z, xAxis, yAxis;

    var drag = {
      start: [],
      stop: []
    };

    var CUTOFF_RADIUS;
    const cutoff = {
      min: 0.05,
      max: 0.2
    };

    const width = 1000;
    const height = 300;
    const margins = {
      left: 30,
      right: 20,
      top: 20,
      bottom: 20
    };
    const TTL_HIGH = 5;

    generateLookup();
    getSequence();

    // Implement shift-click
    $(".check-channel").click(function() {
      const id = $(this).attr('id');
      var index = checkState.lookupList
                    .findIndex(element => element === id);

      if (checkState.last >= 0 && checkState.shiftPressed) {
        var poll = 0;
        const i0 = Math.min(index, checkState.last);
        const i1 = Math.max(index, checkState.last);
        const idlist = checkState.lookupList.slice(i0, i1);
  
        idlist.forEach(function(k,i) {
            poll += ($("#"+k).is(":checked")) ? 1 : -1;
          });
        const state = (poll > 0) ? false : true;
        idlist.forEach(function(k,i) {
          $("#"+k).prop("checked", state);
        });
      }
      checkState.last = index;
    });

    $(".check-channel").change(function() {
      updatePlot()
    });

    // Watch for shift, for shift-clicking
    $(document).keydown(function(event) {
      if (event.which == 16) {
        checkState.shiftPressed = true;
      }
    })
    .keyup(function(event) {
      if (event.which == 16) {
        checkState.shiftPressed = false;
      }
    });

    // Enables all channels in a device
    $(".btn-channel-enable").click(function() {
      const dev = $(this).attr("data-device");
      $(".check-channel-"+dev).prop("checked", true);
      updatePlot();
    });
    
    // Disables all channels in a device
    $(".btn-channel-disable").click(function() {
      const dev = $(this).attr("data-device");
      $(".check-channel-"+dev).prop("checked", false);
      updatePlot();
    });

    // Disables all channels
    $(".btn-channel-all-off").click(function() {
      $(".check-channel").prop("checked", false);
      updatePlot();
    });

    // Disables all channels
    $(".btn-channel-all-on").click(function() {
      $(".check-channel").prop("checked", true);
      updatePlot();
    });

    function updatePlot() {
      // Empty array
      sequence_array.length = 0;
      // Loop through checkboxes
      $(".check-channel:checked").each(function() {
        var $idn = $(this).attr('data-nameloc');
        sequence_array.push(
          {
            nameloc: $idn,
            data: sequence[$idn]
          }
        );
      });

      if ($(".check-scale").is(":checked")) {
        sequence_array.forEach(function(d,i) {
          // Remember that each step in d.data is [time, value]
          let max = Math.max(-1.0*d3.min(d.data, x => x[1]), d3.max(d.data, x => x[1]));
          // Avoid divide by zero
          max = Math.max(1, max);
          sequence_array[i].data = d.data.map(x => [x[0], x[1] / max]);
        });

        y = d3.scaleLinear()
          .domain([-1, 1])
          .range([height - margins.top, margins.bottom]);
        yAxis = d3.axisLeft(y);

        svg.select("g.y.axis")
            .call(yAxis);

        CUTOFF_RADIUS = cutoff.min;
      }
      else {
        sequence_array.forEach(function(d,i) {
          if (typeLookup[d.nameloc] === "digital") {
            sequence_array[i].data = d.data.map(x => [x[0], TTL_HIGH*x[1]]);
          }
        });

        y = d3.scaleLinear()
          .domain([-10, 10])
          .range([height - margins.top, margins.bottom]);
        yAxis = d3.axisLeft(y);

        svg.select("g.y.axis")
            .call(yAxis);

        CUTOFF_RADIUS = cutoff.max;
      }

      z = d3.scaleOrdinal(d3.schemeCategory10)
        .domain(Array.from(Array(10).keys()));

      const path = svg.select("g.lines")
        .selectAll("path")
          .data(sequence_array)
            .join("path")
            .attr("fill", "none")
            .attr("stroke-width", 2)
            .attr("stroke", (d,i) => z(i % 10))
            .attr("d", d => line(d.data));
      
      svg.call(mouseActions, path);
    }

    function mouseActions(svg, path) {
      svg.on("mousemove", moved)
        .on("mouseenter", entered)
        .on("mouseleave", left)
        .on("mousedown", dragStarted)
        .on("mouseup", dragDone);

      const rect = svg.append("g");
      rect.append("rect")
          .attr("x", 0)
          .attr("y", 0)
          .attr("width", 0)
          .attr("height", 0)
          .attr("fill", "none")
          .attr("stroke", "none");

      var xstart, ystart;
      var dragging = false;

      const dot = svg.append("g")
        .attr("display", "none");
      dot.append("circle")
        .attr("r", 2.5);
      dot.append("text")
          .attr("font-family", "sans-serif")
          .attr("font-size", 10)
          .attr("text-anchor", "middle")
          .attr("y", -10);

      function dragStarted() {
        d3.event.preventDefault();
        ystart = d3.event.layerY;
        xstart = d3.event.layerX;
        dragging = true;
      }
      function dragDone () {
        const xend = x.invert(d3.event.layerX - margins.left);
        const yend = y.invert(d3.event.layerY - margins.top);

        const xstartd = x.invert(xstart - margins.left);
        const ystartd = y.invert(ystart - margins.top);

        x = d3.scaleLinear()
          .domain(d3.extent([xstartd, xend]))
          .range([margins.left, width - margins.right]);
        xAxis = d3.axisBottom(x);

        y = d3.scaleLinear()
          .domain(d3.extent([ystartd, yend]))
          .range([height - margins.top, margins.bottom]);
        yAxis = d3.axisLeft(y);

        svg.select("g.x.axis")
          .call(xAxis);

        svg.select("g.y.axis")
          .call(yAxis);
   
        line = d3.line()
        	.x(d => x(d[0]))
        	.y(d => y(d[1]));

        path.attr("d", d => line(d.data));

        rect.select("rect")
          .attr("stroke", "none");
        dragging = false;
      }
      function moved() {
        d3.event.preventDefault();

        if (dragging) {
          const xx = d3.event.layerX;
          const yy = d3.event.layerY;

          const xc = xstart < xx ? xstart : xx;
          const yc = ystart < yy ? ystart : yy;

          const ww = Math.abs(xx - xstart);
          const hh = Math.abs(yy - ystart);

          rect.attr("transform", "translate(" + xc + "," + yc + ")");
          rect.select("rect")
            .attr("x", 0)
            .attr("y",0)
            .attr("width", ww)
            .attr("height", hh)
            .attr("stroke", "black")
            .attr("stroke-dasharray", 10);
        }
        else {
          const ym = y.invert(d3.event.layerY - margins.top);
          const xm = x.invert(d3.event.layerX - margins.left);

          // Yikes! This looks gnarly but is not so bad
          // We need to get the closest x-axis data value to our mouse
          // If we have an ordered array ts = [t0, t1, t2, ...], bisectLeft(ts, t)
          // returns the index where we can insert t
          // However need to do several maps over this to get into the correct arrays
          const i0s = sequence_array.map(d => d3.bisectLeft(d.data.map(x => x[0]), xm, 1));
          const i1s = i0s.map(d => d - 1);

          // Again looks gnarly. Just want to find whether xm is closer to i0s[i] or i1s[i]
          // for each i
          const is = sequence_array.map(
            (d,i) => (d.data[i0s[i]][0] - xm > xm - d.data[i1s[i]][0]) ? i1s[i] : i0s[i]
          );
          const dys = sequence_array.map((d, i) => Math.abs(ym - d.data[is[i]][1]));

          var outer = 0;
          let temp = dys[0];
          for (let j=0; j < dys.length; j++) {
            if (dys[j] < temp) {
              temp = dys[j];
              outer = j;
            }
          }
          const inner = is[outer];
          const val = sequence_array[outer].data[inner];

          path.attr("stroke", (d,i) => outer === i ? z(i % 10) : "#ddd")
            .filter((d,i) => outer === i).raise();

          dot.attr("transform", "translate("+ x(val[0]) + "," + y(val[1]) + ")")
          dot.select("text")
            .text(sequence_array[outer].nameloc);
        }
      }
      function entered() {
        path.attr("stroke", "#ddd");
        dot.attr("display", null);
      }
      function left() {
        path.attr("stroke", (d, i) => z(i % 10));
        dot.attr("display", "none");
      }
    }


    // Generate the list of channels
    function generateLookup() {
      $(".check-channel").each(function() {
        checkState.lookupList.push($(this).attr("id"));
        typeLookup[$(this).attr("data-nameloc")] = $(this).attr("data-type");
      });
    }

    function getSequence() {
      const session = {
        experiment: "{{session.0}}",
        date: "{{session.1}}",
        version: "{{session.2}}"
      };
      var qstr = $.param(session);
      $.getJSON("./sequence?" + qstr)
        .done(function(data) {
          sequence = data.plottable;
          meta = data.meta;

          setupPlots();
        });
    }

    function setupPlots() {
      svg.attr('width', width)
        .attr('height', height);

      x = d3.scaleLinear()
        .domain([0, 40])
        .range([margins.left, width - margins.right]);
      xAxis = d3.axisBottom(x);

      y = d3.scaleLinear()
        .domain([-5, 5])
        .range([height - margins.top, margins.bottom]);
      yAxis = d3.axisLeft(y);

      line = d3.line()
      	.x(d => x(d[0]))
      	.y(d => y(d[1]));

      svg.attr("transform", "translate(" + margins.left + "," + margins.top + ")");

      svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + (height - margins.bottom) + ")")
        .call(xAxis);

      svg.append("g")
        .attr("class", "y axis")
        .attr("transform", "translate(" + margins.left + ",0)")
        .call(yAxis);

      svg.append("g")
        .attr("class", "lines")

//      const path = svg.append("g")
//        .selectAll("path")
//          .data(sequence_array)
//          .join("path")
//            .attr("class", "line")
//            .attr("d", d => line(d.data));

//      const lines = svg.selectAll("lines")
//        .data(sequence_array)
//        .enter()
//        .append("g");
//      
//      lines.append("path")
//        .attr("class", "line")
//        .attr("d", d => line(d.data));

//      svg.append("path")
//        .datum(sequence["DAC0: QTrap Voltage@I00"])
//        .attr("class", "line")
//        .attr("d", line);
    }


  </script>

{% else %}
  <h2>Sorry you haven't loaded a sequence!!!</h2>
{% endif %}
{% endblock %}
